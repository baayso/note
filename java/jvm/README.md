# JVM（Java Virtual Machine，Java虚拟机）

### JVM内存结构

### GC作用区域

### 判断对象是否可回收
* 引用计数法
  * 引用和对象是有关联的，如果要操作对象则必须使用引用进行。
  * 因此，一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单的说，给对象中添加一个引用计数器。
    * 每当有一个地方引用它，计数器值加1；
    * 每当有一个引用失效时，计数器值减1。
  * 任何时刻计数器值为零的对象就是不可以再被使用的，那么这个对象就是可回收对象。
  * 缺点：
    * 每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗；
    * **引用计数法很难解决对象之间相互循环引用的问题，所以主流的JVM都没有选用这种算法。**
      * 比如说A对象的一个属性引用B，B对象的一个属性同时引用A，`A.b = B(); B.a = A();`此时A和B对象的计数器都是1，但是，如果没有其他任何地方引用A和B对象的时候，A、B对象其实在系统中是无法发挥任何作用的，既然无法发挥作用那就应该被视为内存垃圾予以清理掉，可是因为此时A和B的计数器的值都是1，虚拟机就无法回收A、B对象。这样就会造成内存浪费。
      * 解决办法：在语言层面处理, 例如Objective-C就使用强弱引用类型来解决这个问题。强引用计数器加1，弱引用不增加。
* 可达性分析算法（枚举根节点做可达性分析，根搜索路径）
  * 为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。
  * 基本思路就是**通过一系列成为`GC Roots`的对象作为起始点**，从这个被称为`GC Roots`的对象开始向下搜索，如果一个对象到`GC Roots`没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活；没有被遍历到的就被判定为死亡。
  * 所谓`GC Roots`或者说`tracing GC`的“根节点”**就是一组必须活跃的引用**。
  * Java中可以作为`GC Roots`的对象
    * 虚拟机栈（栈帧中的局部变量表）
    * 方法区中的类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中JNI（Native方法）引用的对象

### 

### GC（Garbage Collection，垃圾回收）算法
* 引用计数
* 复制
* 标记-清除
* 标记-清除-整理

###
